const container = document.getElementById('container');

function resolveCtor(name) {
  if (typeof window[name] !== 'undefined') return window[name];
  if (typeof THREE !== 'undefined' && typeof THREE[name] !== 'undefined') return THREE[name];
  return null;
}

function startApp() {
  // cena / câmera / renderizador
  const cena = new THREE.Scene();
  cena.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    1000
  );
  camera.position.set(2.5, 2.5, 3.5);

  const renderizador = new THREE.WebGLRenderer({ antialias: true });
  renderizador.setPixelRatio(window.devicePixelRatio || 1);
  renderizador.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderizador.domElement);

  try {
    if ('outputColorSpace' in renderizador && 'SRGBColorSpace' in THREE) {
      renderizador.outputColorSpace = THREE.SRGBColorSpace;
    } else if ('outputEncoding' in renderizador && 'sRGBEncoding' in THREE) {
      renderizador.outputEncoding = THREE.sRGBEncoding;
    }
  } catch (e) { }

  // controls
  const ControlsCtor = resolveCtor('OrbitControls');
  const controles = new ControlsCtor(camera, renderizador.domElement);
  controles.target.set(0, 0, 0);
  controles.enableDamping = true;
  controles.dampingFactor = 0.07;

  // luzes
  cena.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
  const luzDirecional = new THREE.DirectionalLight(0xffffff, 0.8);
  luzDirecional.position.set(3, 10, 5);
  cena.add(luzDirecional);

  // pós-processamento (outline)
  const composer = new THREE.EffectComposer(renderizador);
  const renderPass = new THREE.RenderPass(cena, camera);
  composer.addPass(renderPass);

  const outlinePass = new THREE.OutlinePass(
    new THREE.Vector2(container.clientWidth, container.clientHeight),
    cena,
    camera
  );
  outlinePass.edgeStrength = 8;
  outlinePass.edgeGlow = 1;
  outlinePass.edgeThickness = 2;
  outlinePass.visibleEdgeColor.set('#00ffff');
  outlinePass.hiddenEdgeColor.set('#00ffff');
  composer.addPass(outlinePass);

  const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
  fxaaPass.uniforms['resolution'].value.set(
    1 / container.clientWidth,
    1 / container.clientHeight
  );
  composer.addPass(fxaaPass);

  // loaders
  const MTLCtor = resolveCtor('MTLLoader');
  const OBJCtor = resolveCtor('OBJLoader');

  const arquivoObj = 'modelos/TechTeen.obj';
  const arquivoMtl = 'modelos/TechTeen.mtl';

  const carregadorMtl = new MTLCtor();
  carregadorMtl.load(arquivoMtl, (materiais) => {
    materiais.preload();

    const carregadorObj = new OBJCtor();
    try { carregadorObj.setMaterials(materiais); } catch (e) { }

    carregadorObj.load(
      arquivoObj,
      (objeto) => {
        // centraliza e escala
        const caixa = new THREE.Box3().setFromObject(objeto);
        const tamanho = caixa.getSize(new THREE.Vector3());
        const centro = caixa.getCenter(new THREE.Vector3());
        objeto.position.sub(centro);
        const maiorDim = Math.max(tamanho.x, tamanho.y, tamanho.z);
        if (maiorDim > 0) objeto.scale.multiplyScalar(1.6 / maiorDim);

        objeto.traverse((filho) => {
          if (filho.isMesh) {
            if (!filho.material) {
              filho.material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            }
            filho.material.side = THREE.FrontSide;
            filho.receiveShadow = true;
          }
        });

        cena.add(objeto);

        // hover com Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
          const rect = container.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);

          const intersects = raycaster.intersectObject(objeto, true);
          outlinePass.selectedObjects = intersects.length > 0 ? [objeto] : [];
        }

        window.addEventListener('mousemove', onMouseMove, false);

        // ajusta controles
        const centroObj = new THREE.Box3().setFromObject(objeto).getCenter(new THREE.Vector3());
        controles.target.copy(centroObj);
        controles.update();
      }
    );
  });

  // loop de animação
  function animar() {
    requestAnimationFrame(animar);
    controles.update();
    composer.render();
  }
  animar();

  // resize
  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderizador.setSize(container.clientWidth, container.clientHeight);
    composer.setSize(container.clientWidth, container.clientHeight);
  });
}

function initWhenReady(timeoutMs = 3000) {
  const allDefined = () => {
    if (typeof THREE === 'undefined') return false;
    return resolveCtor('OrbitControls') && resolveCtor('OBJLoader') && resolveCtor('MTLLoader');
  };

  if (allDefined()) { startApp(); return; }

  let waited = 0;
  const step = 100;
  const interval = setInterval(() => {
    if (allDefined()) {
      clearInterval(interval);
      startApp();
    } else if ((waited += step) >= timeoutMs) {
      clearInterval(interval);
      console.error('three.js (ou OrbitControls/OBJLoader/MTLLoader) não carregou no tempo esperado.');
    }
  }, step);
}

document.addEventListener('DOMContentLoaded', () => initWhenReady());
